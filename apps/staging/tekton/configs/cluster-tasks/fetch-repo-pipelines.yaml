apiVersion: tekton.dev/v1beta1
kind: ClusterTask
metadata:
  name: fetch-repo-pipelines
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.37.0"
    tekton.dev/categories: kubernetes
    tekton.dev/tags: kubernetes
    tekton.dev/displayName: fetch repo pipelines
    tekton.dev/platforms: "linux/amd64"
spec:
  description: Get self pipeline manifest in repo.
  workspaces:
    - name: output
      description: Save all the pipeline manifest files.
  params:
    - name: git-url
      description: |
        The GitHub repository full url, e.g.: https://github.com/tektoncd/catalog.git
      type: string
    - name: git-revision
      description: |
        Commit SHA to get ci pipeline manifests.
      type: string
      default: main
    - name: context
      type: string
      default: .ci
      description: CI manifest dir.
    - name: output
      type: string
      default: "ci.yaml"
      description: ci manifest parsed output file path.
    - name: github-app-secret
      description: |
        The name of the kubernetes secret that contains the GitHub app id and private key token.
      type: string
      default: github-app
  volumes:
    - name: github-app-secret
      secret:
        secretName: $(params.github-app-secret)
  steps:
    - name: prepare-script
      image: denoland/deno:1.23.3
      workingDir: $(workspaces.output.path)
      script: |
        #!/usr/bin/env bash

        cat <<EOF > get.ts
        import { parse } from "https://deno.land/std@0.147.0/flags/mod.ts";
        import { stringify as yamlStringify } from "https://deno.land/std@0.147.0/encoding/yaml.ts";
        import { decode as base64Decode } from "https://deno.land/std@0.147.0/encoding/base64.ts";
        import { Octokit, App } from "https://cdn.skypack.dev/octokit?dts";

        const DEFAULT_CI_DIR = ".ci";
        const DEFAULT_CI_MANIFEST_OUTPUT = "ci.yaml"

        /**
        * typescript style guide: https://google.github.io/styleguide/tsguide.html
        */

        interface gitParams {
            appId: number;
            privateKeyPath: string;
            gitUrl: string;
            reversion: string;
            ciDir?: string;
            output?: string;
        }

        interface ciFileBlob {
            file_sha: string;
            path: string;
            content: string;
        }

        function parseRepo(gitUrl: string): { repo: string, owner: string } {
            const url = new URL(gitUrl);
            console.log(url.pathname)
            const [repo, owner] = url.pathname.split("/", 2)
            return { repo, owner };
        }

        async function getRepoOctokit(
            app: App,
            owner: string,
            repo: string,
        ): Promise<Octokit> {
            let ret: Octokit;
            await app.eachRepository(({ octokit, repository }) => {
                if (repository.full_name === `${owner}/${repo}`) {
                    ret = octokit;
                }
            });

            return ret;
        }

        async function getCiFiles(
            octokit: Octokit,
            owner: string,
            repo: string,
            sha: string,
            dir: string,
        ) {
            // get tree path
            const { data: { tree: dirs } } = await octokit.rest.git.getTree({
                owner: owner,
                repo: repo,
                tree_sha: sha,
            });

            // find dir
            const matched = dirs.find(
                (e: { path?: string; type?: string; sha: string }) => {
                    return e.path === dir && e.type === "tree";
                },
            );

            // get files
            const { data: { tree } } = await octokit.rest.git.getTree({
                owner: owner,
                repo: repo,
                tree_sha: matched.sha,
                recursive: true,
            });

            return await Promise.all(tree.
                filter(f => f.path.endsWith(".yaml") || f.path.endsWith(".yml")).
                map(async (f) => {
                    const { data: { content } } = await octokit.rest.git.getBlob({ owner, repo, file_sha: f.sha });
                    const file_content = new TextDecoder().decode(base64Decode(content));

                    return { path: f.path, file_sha: f.sha, content: file_content } as ciFileBlob;
                })
            );
        }

        async function main(params: gitParams) {
            const { appId, privateKeyPath, gitUrl, reversion } = params;
            const { owner, repo } = parseRepo(gitUrl);

            let { ciDir, output } = params;
            if (!ciDir) {
                ciDir = DEFAULT_CI_DIR;
            }
            if (!output) {
                output = DEFAULT_CI_MANIFEST_OUTPUT
            }

            // decode private key from base64 encoded string
            const privateKey = await Deno.readTextFile(privateKeyPath);
            const app = new App({ appId, privateKey });
            const { data: { slug } } = await app.octokit.rest.apps.getAuthenticated();
            console.log({ slug });

            const files = await getCiFiles(
                await getRepoOctokit(app, owner, repo),
                owner,
                repo,
                reversion,
                ciDir,
            );
            files.forEach((f) => console.log(f));

            await Deno.writeFile(output, new TextEncoder().encode(yamlStringify(files)))
        }

        const cliArgs = parse(Deno.args);
        await main(cliArgs as unknown as gitParams);
        console.log("~~~~~~~~~~~end~~~~~~~~~~~~~~");

        /**
        * FIXME: A bug in [octokit](https://github.com/octokit/octokit.j).
        * current I need call an `exit` at the end of deno script.
        * issue: https://github.com/octokit/octokit.js/issues/2079
        * working in progress: https://github.com/octokit/webhooks.js/pull/693
        */
        Deno.exit(0)

        EOF
    - name: run-script
      image: denoland/deno:1.23.3
      workingDir: $(workspaces.output.path)
      script: |
        #! /usr/bin/env bash

        deno run --allow-read --allow-write --allow-net get.ts \
          --gitUrl="$(params.git-url)" \
          --sha=$(params.git-revision) \
          --ciDir=$(params.context) \
          --output=$(params.output) \
          --appId="$(cat /etc/github-app-secret/app-id)" \
          --privateKeyPath=/etc/github-app-secret/app-cert-pkcs8

      volumeMounts:
        - name: github-app-secret
          mountPath: /etc/github-app-secret
